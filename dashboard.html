<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Filtered Regression History</title>
  <!-- Add Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind with custom colors for test states
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'test-pass': 'rgb(21 128 61)',   // Tailwind green-700
            'test-fail': 'rgb(190 18 60)',   // Tailwind rose-700
            'test-skip': '#f59e0b',  // Bright amber
            'header-bg': '#f8fafc',
          }
        }
      }
    }
  </script>
  <style>
    /* Add this to handle text truncation */
    .test-name {
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      direction: rtl;  /* This makes the truncation happen at the start */
      text-align: left;
    }
  </style>
</head>
<body class="bg-gray-50">
  <div class="w-full px-6 pb-8">
    <div class="relative overflow-x-auto shadow-lg rounded-lg border border-gray-200">
      <table id="history-table" class="w-full text-sm text-left">
        <thead>
          <tr class="bg-header-bg border-b border-gray-200">
            <th class="sticky left-0 bg-header-bg px-4 py-4 font-semibold text-gray-700 w-[300px]">Test Node</th>
            <!-- Run-date columns appended by JS -->
          </tr>
        </thead>
        <tbody class="bg-white">
          <!-- Rows appended by JS -->
        </tbody>
      </table>
    </div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

    const SUPABASE_URL = 'https://ynesgbuoxmszjrkzazxz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InluZXNnYnVveG1zempya3phenh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzNzg5NDYsImV4cCI6MjA0OTk1NDk0Nn0.6KxEoSHTgyV4jKnnLAG5-Y9tWfHOzpl0qnA_NPzGUBo';
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const MAX_RUNS = 100000;
    const REFRESH_INTERVAL = 5 * 60 * 1000;  // Refresh every 5 minutes

    async function refreshTable() {
      // Clear existing table content
      document.querySelector('#history-table thead tr').innerHTML = `
        <th class="sticky left-0 bg-gray-100 px-3 py-3 font-semibold w-[300px]">Test Node</th>
      `;
      document.querySelector('#history-table tbody').innerHTML = '';
      
      // Rebuild the table
      await buildHistoryTable();
      
      // Schedule next refresh
      setTimeout(refreshTable, REFRESH_INTERVAL);
    }

    // Update the status mapping and classes
    const statusClasses = {
      'passed': 'bg-green-600/80 text-white font-medium px-3 py-1 text-xs uppercase tracking-wider border border-green-700/60',
      'failed': 'bg-red-600/80 text-white font-medium px-3 py-1 text-xs uppercase tracking-wider border border-rose-700/60',
      'skipped': 'bg-test-skip/40 text-test-skip font-medium px-3 py-1 text-xs uppercase tracking-wider border border-test-skip/60',
      'not_run': 'bg-gray-50 text-gray-400 font-medium px-3 py-1 text-xs uppercase tracking-wider border border-gray-200'
    };

    function sortTable(columnIndex) {
      const tbody = document.querySelector('#history-table tbody');
      const rows = Array.from(tbody.querySelectorAll('tr'));
      
      // Get current sort direction from the header
      const th = document.querySelector(`#history-table th:nth-child(${columnIndex + 1})`);
      const ascending = th.dataset.sortDir !== 'asc';
      
      // Update sort direction indicators on all headers
      document.querySelectorAll('#history-table th').forEach(header => {
        header.dataset.sortDir = '';
        header.classList.remove('after:content-["↑"]', 'after:content-["↓"]', 'after:ml-2');
      });
      
      // Update current header's sort direction
      th.dataset.sortDir = ascending ? 'asc' : 'desc';
      th.classList.add(
        ascending ? 'after:content-["↑"]' : 'after:content-["↓"]',
        'after:ml-2'
      );

      // Sort the rows
      rows.sort((rowA, rowB) => {
        const cellA = rowA.cells[columnIndex].textContent;
        const cellB = rowB.cells[columnIndex].textContent;
        
        if (columnIndex === 0) {
          // Sort test names alphabetically
          return ascending ? 
            cellA.localeCompare(cellB) : 
            cellB.localeCompare(cellA);
        } else {
          // Sort test results (PASS > FAIL > SKIP > N/A)
          const resultOrder = { 'PASS': 0, 'FAIL': 1, 'SKIP': 2, 'N/A': 3 };
          const valueA = resultOrder[cellA] ?? 4;
          const valueB = resultOrder[cellB] ?? 4;
          return ascending ? valueA - valueB : valueB - valueA;
        }
      });

      // Reinsert rows in sorted order
      rows.forEach(row => tbody.appendChild(row));
    }

    async function buildHistoryTable() {
      // 1. Fetch the most recent runs first
      let { data: allRuns, error: runsError } = await supabase
        .from('test_runs')
        .select('id, start, githash')
        .order('start', { ascending: false })
        .limit(MAX_RUNS);
      if (runsError) {
        console.error('Error fetching test_runs:', runsError);
        return;
      }

      // 2. Fetch test results for these specific runs
      let { data: regressionResults, error: resultsError } = await supabase
        .from('test_results')
        .select('*')
        .eq('file', 'test/test_regressions.py')
        .in('test_runs_id', allRuns.map(run => run.id))
        .order('test_runs_id', { ascending: false });
      if (resultsError) {
        console.error('Error fetching test_results:', resultsError);
        return;
      }

      let runs = allRuns;  // Use all runs without filtering

      // Filter out runs where all tests were skipped
      runs = runs.filter(run => {
        const runResults = regressionResults.filter(r => r.test_runs_id === run.id);
        console.log(`Run ${run.id} (${new Date(run.start).toISOString()}) has ${runResults.length} results`);
        const hasNonSkip = runResults.some(result => result.outcome === 'passed' || result.outcome === 'failed');
        if (!hasNonSkip) {
          console.log(`Filtering out run ${run.id} as all results were skipped`);
        }
        return hasNonSkip;
      });

      // Possibly limit to the last MAX_RUNS columns
      if (runs.length > MAX_RUNS) {
        runs = runs.slice(runs.length - MAX_RUNS);
      }

      // 3. Build a map: (nodeid, runID) -> outcome, plus gather node IDs
      const outcomeMap = {};
      const nodeSet = new Set();
      regressionResults.forEach(r => {
        // Strip the env suffix for grouping
        const baseNodeId = r.nodeid
          .replace(/-env\d+([^\]]*)$/, '$1')           // Remove -envX at the end
          .replace(/\[([^\]]+)-env\d+([^\]]*)\]/, '[$1$2]')  // Remove -envX inside brackets
          .replace(/-env\d+(?=-)/, '');                // Remove -envX in the middle
        nodeSet.add(baseNodeId);
        
        // Combine results, prioritizing PASS/FAIL over SKIP
        const key = `${baseNodeId}-${r.test_runs_id}`;
        const existingOutcome = outcomeMap[key];
        if (!existingOutcome || 
            (existingOutcome === 'skipped' && (r.outcome === 'passed' || r.outcome === 'failed'))) {
          outcomeMap[key] = r.outcome;
        }
      });

      // Build table headers for each run
      const theadRow = document.querySelector('#history-table thead tr');
      runs.forEach((run, index) => {
        const th = document.createElement('th');
        th.className = 'px-4 py-4 font-semibold text-gray-700 cursor-pointer hover:bg-gray-100 transition-colors';
        
        const shortHash = run.githash ? run.githash.slice(-7) : 'unknown';
        const date = new Date(run.start);
        
        // Create structured header content
        th.innerHTML = `
          <div class="flex flex-col items-center gap-1">
            <span class="font-mono text-xs text-gray-500">${shortHash}</span>
            <span class="text-sm">${date.toLocaleDateString()}</span>
            <span class="text-xs text-gray-500">${date.toLocaleTimeString([], { 
              hour: '2-digit', 
              minute: '2-digit',
              hour12: false
            })}</span>
          </div>
        `;
        
        th.addEventListener('click', () => sortTable(index + 1));
        theadRow.appendChild(th);
      });

      // Add click handler to the Test Node column header
      const firstTh = theadRow.querySelector('th');
      firstTh.className += ' cursor-pointer hover:bg-gray-200 transition-colors';
      firstTh.addEventListener('click', () => sortTable(0));

      // 4. For each node ID, build a row for these runs
      const tbody = document.querySelector('#history-table tbody');
      const allNodeIds = Array.from(nodeSet).sort();
      allNodeIds.forEach(nodeid => {
        const tr = document.createElement('tr');
        tr.className = 'border-b hover:bg-gray-50';

        const testCell = document.createElement('td');
        testCell.className = 'sticky left-0 bg-white px-4 py-3 whitespace-nowrap test-name font-mono text-sm text-gray-700 border-r border-gray-100';
        const shortNodeId = cleanTestName(nodeid);
        testCell.textContent = shortNodeId;
        tr.appendChild(testCell);

        runs.forEach(run => {
          const td = document.createElement('td');
          td.className = 'px-4 py-3 text-center';
          const outcome = outcomeMap[`${nodeid}-${run.id}`];
          
          if (!outcome || outcome === '') {
            td.textContent = "Not Run";
            td.className += ' ' + statusClasses['not_run'];
          } else {
            td.textContent = outcome === 'passed' ? 'PASS' : 
                            outcome === 'failed' ? 'FAIL' : 
                            'SKIP';
            td.className += ' ' + statusClasses[outcome.toLowerCase()];
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    // Update the cleanTestName function
    function cleanTestName(nodeid) {
      return nodeid
        .split('::').pop()  // Get the last part after ::
        .replace(/test_projects\[https?:\/\/[^\/]+\/[^\/]+\/([^\]]+)\]/g, 'test_projects[$1]')  // More specific pattern
        .replace(/\[https?:\/\/[^\/]+\/[^\/]+\/([^\]]+)\]/g, '[$1]');  // Backup pattern
    }

    // Start the refresh cycle
    refreshTable();

    // Add hover effect to rows
    document.querySelectorAll('#history-table tbody tr').forEach(row => {
      row.classList.add('hover:bg-gray-50', 'transition-colors');
    });
  </script>

  <!-- Add custom styles -->
  <style>
    /* Smooth scrolling */
    .overflow-x-auto {
      scroll-behavior: smooth;
    }
    
    /* Better sticky header shadow */
    thead tr {
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Fade edges when scrolling horizontally */
    .overflow-x-auto::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 40px;
      background: linear-gradient(to right, transparent, white);
      pointer-events: none;
    }
  </style>
</body>
</html>
